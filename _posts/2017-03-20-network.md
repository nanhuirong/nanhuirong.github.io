---
layout: post
title: Java网路编程
---

***

### 网络分层
+ 主机网络层(又称链路层)
+ 网际层(网络层): IP网络层协议, 包含IPv4(32位)和IPv6(128位)<br>
>数据位和字节如何组织成包, 数据报(datagram), IPV4包含20-60字节的首部和65515个字节的数据<br>
>寻址机制<br>
>使用同构协议将异构网络链接<br>
+ 传输层： 保证数据包以发送的顺序接受, 保证没有数据丢失和破坏<br>
>如果丢包, 会请求发送方重传<br>
>包含两种协议:TCP(支持数据重传, 并按照发送的顺序进行传送) UDP(允许接收方检测被破坏的包, 并不保证数据包以正确的顺序进行传送), ICMP(使用原始IP数据报在主机之间传递错误消息)<br>
+ 应用层<br>
>web:HTTP<br>
>电子邮件:SMTP, POP, IMAP<br>
>文件传输:FTP, FSP, TFTP<br>
>文件访问:NFS<br>
>文件共享:Gnutella, BitTorrent<br>
>语音通信:Session Initiation Protocol, Skype<br>

### IP与端口
+ /etc/services存储端口和协议的对应关系
+ 地址分块<br>
>最低地址标识网络本身, 最高地址是网络的广播地址<br>
+ 地址转换NAT<br>
>不可路由地址: 10.x.x.x.x 172.16.x.x 172.31.x.x 192.168.x.x<br>
>出站: 将源地址改为路由器的外部地址<br>
>入站: 将目的地址改为一个本地地址<br>
+ 防火墙 Internet和本地网络之间的一些硬件和软件会检查所有进出的数据<br>
>工作于传输层和网际层
+ 代理服务器<br>
>工作于应用层

### JAVA流
+ 基本输出流java.io.OutputStream<br>
>FileOutputStream: 将数据写入文件<br>
>TelnetOutputStream: 将数据写入网络<br>
>ByteArrayOutputStream: 将数据写入可扩展的字节数组<br>
+ 基本输入字节流<br>
>FileInpputStream<br>
>TelnetInputStream<br>
>ByteArrayInputStream<br>
+ 其他流<br>
>BufferedInputStream<br>
>BufferedOutputStream<br>
>PrintStream<br>
>DataInputStream 和DataOutputStream<br>
+ Reader 和 Writer<br>
>InputStreamReader 和 OutputStreamWriter<br>
>FileReader FileWriter<br>
>StringReader 和 StringWriter<br>
>CharArrayReader 和 CharArrayWriter<br>
>FileReader 和 FileWriter<br>
>BufferedReader 和 BufferedWriter<br>
>LineNumberReader<br>
>PushbackReader<br>
>PrintWriter<br>

### 线程
+ 线程实现回调功能
```java
public class FindMaxTask implements Callable<Integer> {
    private int[] data;
    private int start;
    private int end;
    public FindMaxTask(int[] data, int start, int end) {
        this.data = data;
        this.start = start;
        this.end = end;
    }
    @Override
    public Integer call() throws Exception {
        int max = Integer.MIN_VALUE;
        for (int i = start; i < end; i++){
            if (data[i] > max)
                max = data[i];
        }
        return max;
    }
}
public class MultithreadMaxFinder {
    public static int max(int[] data) throws ExecutionException, InterruptedException {
        if (data.length == 1){
            return data[0];
        }else if (data.length == 0){
            throw new IllegalArgumentException();
        }
        FindMaxTask task1 = new FindMaxTask(data, 0, data.length / 2);
        FindMaxTask task2 = new FindMaxTask(data, data.length / 2, data.length);
        ExecutorService service = Executors.newFixedThreadPool(2);
        Future<Integer> future1 = service.submit(task1);
        Future<Integer> future2 = service.submit(task2);
        return Math.max(future1.get(), future2.get());
    }
}
```

+ 线程API<br>
>Thread.yield() 线程放弃控制权<br>
>Thread.interrupt() 唤醒休眠线程<br>
>Thread.join() 允许线程在继续执行前等待其他线程执行完毕, 现在可以使用Executor和Future来实现<br>
>Object.wait() 等待, 它会释放这个对象的锁并暂停<br>
>Object.notify() 通知一个线程<br>
>Object.notifyAll() 通知所有线程<br>






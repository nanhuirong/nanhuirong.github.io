---
layout: post
title: 算法
---

### 排序

![排序](https://raw.githubusercontent.com/nanhuirong/nanhuirong.github.io/master/_posts/排序.png)<br>

1.插入排序

2.冒泡排序

3.归并排序<br>
>采用分治思想，变种包括求逆序数对数。基于归并排序的改进可以在子模块<thread 时采用
插入排序进行优化<br>
+ 分治思想
>1）求解最大子数组<br>
>2) 求解矩阵乘法（目前没实现，时间复杂度为O(n^log7 === n^2.81)）<br>

4.堆排序
>堆排序式基于比较的两种最高效的排序算法，
另外一种是快速排序，但是快速排序的性能一般优于堆排序，
甚至于堆排序的性能低于归并排序。<br>
+ 堆排序的应用：优先队列（下列为最大优先队列算法）<br>
>1）插入：利用修改优先级的算法，先插入一个无穷小的数到尾部，再增加优先级<br>
>2）返回最大优先级：<br>
>3）去掉最大优先级：将最后一个提到第一位，调整堆<br>
>4）修改优先级：不断与父节点比较<br>
>5）去掉指定位置的值<br>
+ k路归并算法<br>
>1）循环遍历：时间复杂度O(nk)， 每找一个元素都需要比较k次<br>
>2）最小堆k路归并排序：时间复杂度O(nlogk)两种解决问题的思路<br>
> a）每个链表尾部加一个无穷大的数，表示该值永远不会被取到<br>
> b）将该元素用堆的最后一个元素替换，并调整呢个堆的属性<br>

5.快速排序
>采用分治的思想<br>
>分解：将数组按照index进行分区，第一个区的任意数小于index，第二个区的任意数大于index<br>
>解决：递归调用快速排序，分区进行排序<br>
>合并：不需要合并<br>
---
layout: post
title: 算法
---

### 排序

![排序](https://raw.githubusercontent.com/nanhuirong/nanhuirong.github.io/master/_posts/排序.png)<br>

1.插入排序

2.冒泡排序

3.归并排序<br>
>采用分治思想，变种包括求逆序数对数。基于归并排序的改进可以在子模块<thread 时采用
插入排序进行优化<br>
+ 分治思想<br>
>1）求解最大子数组<br>
>2) 求解矩阵乘法（目前没实现，时间复杂度为O(n^log7 === n^2.81)）<br>

4.堆排序
>堆排序式基于比较的两种最高效的排序算法，
另外一种是快速排序，但是快速排序的性能一般优于堆排序，
甚至于堆排序的性能低于归并排序。<br>
+ 堆排序的应用：优先队列（下列为最大优先队列算法）<br>
>1）插入：利用修改优先级的算法，先插入一个无穷小的数到尾部，再增加优先级<br>
>2）返回最大优先级：<br>
>3）去掉最大优先级：将最后一个提到第一位，调整堆<br>
>4）修改优先级：不断与父节点比较<br>
>5）去掉指定位置的值<br>
+ k路归并算法<br>
>1）循环遍历：时间复杂度O(nk)， 每找一个元素都需要比较k次<br>
>2）最小堆k路归并排序：时间复杂度O(nlogk)两种解决问题的思路<br>
>  a）每个链表尾部加一个无穷大的数，表示该值永远不会被取到<br>
>  b）将该元素用堆的最后一个元素替换，并调整呢个堆的属性<br>

5.快速排序
>采用分治的思想<br>
>分解：将数组按照index进行分区，第一个区的任意数小于index，第二个区的任意数大于index<br>
>解决：递归调用快速排序，分区进行排序<br>
>合并：不需要合并<br>
+ 基于快速排序的改进（主要在于对分区函数的改进）<br>
> 1）随机选取主元<br>
> 2）三个随机数中选择中位数<br>
> 3）当数据几乎有序时, 插入排序很快,当快速排序的长度小于k时,不做任何排序并返回,
并在排序排序结束时调用插入排序O(nk + nlg(n/k))<br>

+ 快速排序的应用
>1）在线性时间复杂度寻找第k小的数<br>

```shell
//各个版本排序的性能统计，对于大量数据排序，O(n^2)的排序性能太差，因而没做统计
产生[0, 50000000)的50000000个随机数花费时间8s
归并排序50000000 46s
产生[0, 50000000)的50000000个随机数花费时间18s
改进归并排序50000000 38s
产生[0, 50000000)的50000000个随机数花费时间24s
堆排序50000000 101s
产生[0, 50000000)的50000000个随机数花费时间35s
快速排序50000000 23s
产生[0, 50000000)的50000000个随机数花费时间36s
随机化版本快速排序50000000 25s
产生[0, 50000000)的50000000个随机数花费时间45s
随机化中位数快速排序50000000 24s
产生[0, 50000000)的50000000个随机数花费时间45s
插入版本快速排序50000000 22s
产生[0, 50000000)的50000000个随机数花费时间4s
归并排序50000000 44s
产生[0, 50000000)的50000000个随机数花费时间21s
改进归并排序50000000 33s
产生[0, 50000000)的50000000个随机数花费时间23s
堆排序50000000 99s
产生[0, 50000000)的50000000个随机数花费时间34s
快速排序50000000 24s
产生[0, 50000000)的50000000个随机数花费时间35s
随机化版本快速排序50000000 25s
产生[0, 50000000)的50000000个随机数花费时间45s
随机化中位数快速排序50000000 26s
产生[0, 50000000)的50000000个随机数花费时间45s
插入版本快速排序50000000 22s
产生[0, 50000000)的50000000个随机数花费时间3s
归并排序50000000 45s
产生[0, 50000000)的50000000个随机数花费时间23s
改进归并排序50000000 33s
产生[0, 50000000)的50000000个随机数花费时间25s
堆排序50000000 102s
产生[0, 50000000)的50000000个随机数花费时间34s
快速排序50000000 24s
产生[0, 50000000)的50000000个随机数花费时间35s
随机化版本快速排序50000000 24s
产生[0, 50000000)的50000000个随机数花费时间45s
随机化中位数快速排序50000000 24s
产生[0, 50000000)的50000000个随机数花费时间46s
插入版本快速排序50000000 22s
```

6.计数排序
>假设输入是0-k区间的整数，排序时间复杂度是O(k)，空间复杂度是O(k)。
需要一个O(k)的临时空间，O(n)空间存放排序后的数据<br>

7.基数排序
>d为数据位数，k为每一位可能的取值<br>

```
radixSort(){
    for i = 1 to d
        使用一个稳定排序排序A的i位（计数排序是一个很好的选择）
}
```

8.桶排序
>假设排序的输入是随机的，需要一个O(n)的临时空间存放桶（类似于一个链表状的结构）<br>

### 数据结构
1.基本数据结构
+ 栈：先进后出
+ 队列：先进先出
+ 链表
+ 树

2.散列表（解决冲突）

3.树形结构
+ 二叉搜索树（二叉排序树，BST）


---
layout: post
title: scala 学习总结
---

### 数据类型
1.值
>val关键字定义<br>

2.变量
>var关键字定义<br>

3.类型
>包含数值类型和非数值类型，没有基本数据类型（类似于java中的int等）<br>

4.scala类型概述

![排序](https://raw.githubusercontent.com/nanhuirong/nanhuirong.github.io/master/_posts/scala类型层次.png)<br>

+ Any：所有类型的根
+ AnyVal：所有值类型的根
+ AnyRef：所有引用类型的根
+ Nothing：所有类型的子类
+ Null：所有指示null的AnyRef类型的子类
+ Unit：指示没有值<br>

>上述类型均不可实例化<br>

5.类型操作
+ asInstanceOf：将某个值转换为指定类型的值，一般用to来代替

```scala
5.asInstanceOf[Long]
```

+ getClass：返回值的类型
+ isInstanceOf[]: 判断该值是否符合指定类型嗯
+ hashCode
+ to<type>：转换为一个兼容的类型
+ toString

6.元组
>包含两个或者多个值的有序容器，并且值的类型可能不同<br>
+ 创建方式

```scala
val info = (1, "nanhuirong", true)
```

### 表达式和条件式
1.表达式块
>利用{}创建一个表达式块，最后一个表达式将作为返回值<br>

2.匹配表达式

```scala
val x = 10
val y = 20
val max = x > y match{
    case true => x
    case false => y
}

val status = 500
val message = status match{
    case 200 => "ok"
    case 400 => {
        println("ERROR-we called the service incorrectly!!!")
        "error"
    }
    case 500 => "error"
}

val day = "MON"
val kind = day match{
    case "MON" | "TUE" | "WEB" | "THU" | "FRI" => "weekday"
    case "SAT" | "SUN" => "weekend"
}
val kind = day match{
    case "MON" | "TUE" | "WEB" | "THU" | "FRI" => "weekday"
    case "SAT" | "SUN" => "weekend"
    case _ => {
        println(s"Could not parse $day")
        -1
    }
}
```

3.循环

```scala
//输出包含7
for(x <- 1 to 7){
    println(s"Day $x")
}

for(x <- 1 to 7) yield {
    println(s"Day $x")
}

//过滤器
val threes = for(i <- 1 to 20 if i % 3 == 0) yield i

val quote = "nan,hui,rong"
for{
    t <- quote.split(',')
    if t != null
    if t.size > 0
}{
    println(t)
}

//嵌套迭代器
for{
    x <- 1 to 2
    y <- 1 to 3
}{
    println(s"($x, $y) ")
}

for(i <- 0 to 8; pow = 1 << i) yield pow

var x = 10
while(x > 0){
    x -= 1
}
```

### 函数

```scala
def multiplier(x: Int, y: Int): Int = {
    x * y
}

def safeTrim(s: String): String = {
    if (s == null) return null
    s.trim()
}
```

1.过程：没有返回值的函数（返回值为Unit）

```scala
def log(d: Double) = println(f"got value $d%.2f")
```

2.递归函数

```scala
def power(x: Int, n: Int): Long = {
    if(n >= 1) x * power(x, n - 1)
     else 1
}

//尾递归优化: 递归代调用必须是这个函数的最后一个语句，可以避免栈溢出
@annotation.tailrec
def power(x: Int, n: Int, t: Int = 1): Long = {
    if(n < 1) t
     else power(x, n - 1, x * t)
}
power(2, 8)

```

3.嵌套函数

```scala
def max(x: Int, y: Int, z: Int): Int = {
    def max(x: Int, y: Int): Int = if(x > y) x else y
    max(x, max(y, z))
}
```

4.有默认参数

```scala
def greet(prefix: String = "", name: String) = s"$prefix$name"
//用命名参数调用函数
val greet1 = greet(name = "Nan")
```

5.vararg参数：匹配调用一个或者多个参数

```scala
def sum(items: Int*): Int = {
    var total = 0
    for(item <- items)
        total += item
    total
}
```

6.参数组

```scala
def max(x: Int)(y: Int) = if(x > y) x else y
```

7.参数类型（解决多函数重载代码量大的问题）

```scala
def identity(a: Any): Any = a

//同一性函数
def identity[A](a: A): A = a
val s = identity("shabi")
```

8.首类函数：不仅能得到声明和调用，还可作为数据类型用在任何地方

```scala
//有单个参数的类型可以省略小括号
def double(x: Int): Int = x * 2
//myDouble 是一个值，可以被调用，首类函数
val myDouble: (Int) => Int = double
//利用通配符为函数赋值
val myDouble = double _
myDouble(5)
val myDoubleCopy = myDouble
myDoubleCopy(5)

def max(x: Int, y: Int) = if(x > y) x else y
val maximize: (Int, Int) => Int = max

```

9.高阶函数: 包含一个函数类型的值作为输入参数或者返回值

```scala
def safeStringOP(s: String, f: String => String) = {
    if(s != null) f(s) else s
}
def reserve(s: String) = s.reserve
safeStringOP(null, reserve)

def tripleOp(a: Int, b: Int, c: Int, f: (Int, Int, Int) => Int) = f(a, b, c)
tripleOp(23, 92, 14, _ * _ + _)

def tripleOp[A, B](a: A, b: A, c: A, f: (A, A, A) => B)= f(a, b, c)
tripleOp[Int, Int](23, 92, 14, _ * _ + _)
triple[Int, Double](23, 92, 14, 1.0 * _ / _ / _)
tripleOp[Int, Boolean](93, 92, 14, _ > _ + _)
```

10.传名参数：可以使用值或者函数调用
```scala
def double(x: => Int) = {
    x * 2
}
//函数调用
double(5)
def f(i: Int) = {i}
double(f(8))
```

11.部分应用函数和柯里化

```scala
//部分应用函数
def factorOf(x: Int, y: Int) = y % x == 0
val f = factorOf _
f(7, 20)
//部分应用函数
val multipleOf = factorOf(3, _: Int)
multipleOf(78)
//函数柯里化
def factorOf(x: Int)(y: Int) = y % x == 0
val isEven = factorOf(2)_
val z = isEven(32)
```

12.偏函数：只能正确处理一部分输入

13.总结

```scala
def safeStringOp(s: String, f: String => String) = {
    if(s != null) f(s) else s
}
val uuid = java.util.UUID.randomUUID.toString
val timeUUID = safeStringOp(uuid, { s =>
    val now = System.currentTimeMillis
    val timed = s.take(24) + now
    timed.toUpperCase
})



def safeStringOp(s: String)(f: String => String) = {
    if(s != null) f(s) else s
}
val timeUUID = safeStringOp(uuid, { s =>
    val now = System.currentTimeMillis
    val timed = s.take(24) + now
    timed.toUpperCase
})


def timer[A](f: => A): A = {
    def now = System.currentTimeMillis
    val start = now; val a = f; val end = now
    println(s"Executed in ${end - start} ms")
    a
}

val verfyRandomAmount = timer{
    util.Random.setSeed(System.currentTimeMillis)
    for(i <- 1 to 100000) util.Random.nextDouble
    util.Random.nextDouble
}
```

### 常用集合
1.不可变集合
>list，Set，Map都是Iterable（可迭代集合）的子类<br>
+ List

```scala
val colors: List[String] = List("red", "green", "blue")
//访问首元素
colors.head
//访问其余元素
colors.tail
colors(0)
for(color <- colors) println(color)

colors.foreach((c: String) => println(c))
colors.map((c: String) => c.size())
colors.reduce((a: Int, b: Int) => a + b)

//遍历集合
var i = colors
while(!i.isEmpty){
    print(i.head + ", ")
    i = i.tail
}

def visit(list: List[String]){
    if(list.size > 0){
    visit(list.tail)
    }
}

while(i != Nil){
    print(i.head + ", ")
    i = i.tail
}
```

>所有列表都有一个Nil作为终节点，是List[Nothing]的单例实例<br>

+ set

```scala
val unique = Set(10, 20, 30, 20, 20, 10)
```

+ map

```scala
val colorMap = Map("red" -> 0xFF0000, "green" -> 0xFF00, "blue" -> 0xFF)
val red = colorMap("red")
val cyanRGB = colorMap("blue") | colorMap("red")
val hasWhite = colorMap.contains("white")
for(pairs <- colorMap) println(pairs)
```




